---
title: "appunti"
author: "Ottavia M. Epifania"
date: "`r Sys.Date()`"
output: html_document
toc: true
---

Quello che serve/può variare: 

- numero di stimuli (quanti per riga e quanti per colonna)

- se si vuole riempire per riga o per colonna (questo lo vedo in un secondo momento) (anche se penso che usando `matrix(c2,2, byrow=F))` si dovrebbe forzare la compilazione per colonna

- la grandezza (fissa, variabile)

- la figura (per ora sono in grado di fare il rettangolo, il triangolo, il quadrato e forse il rombo)

- il riempimento

- bordi (ci sto ancora studiando)

- la posizione del punto interogativo (Rome wasn't built in a day)

## 19/09/2022
### Relation rule 

```{r echo = F, eval=TRUE}
# triangolo ---- 

library(DescTools)
# 19/09/2022 ----- 
# prova generazione di regole con liste e array e tante speranze ---- 
# RELATION: UNARY #
# The same pattern is repeated on each row (the first element determines the second
# and the third)
# which_rot

list(first = c(0.10, 0.50, 0.00), 
     second = c(0.50, 0.00, 0.10), 
     third = c(0.00, 0.10))

rm(rule_relation)
rule_relation = function(rotation = NULL,
    which_rot = c("htv", "vth", 
                                      "dtv", "dth"), shade = NULL, 
                         which_shade = c("wtg", "wtb", "btw", "btg"),
    line = NULL,
                         which_line = c("sdad", "dads", "sdda", "ddas")) {
  the_rule = list()
  # which_rots
    h = 0; d= pi/3; v = pi/2
    rot_rule = list()
    # colors 
    sw = 0; sg = 0.10; sb = 0.6
    shade_rule = list()
    # which_line 
    s = 1; da = 5; do = 3
    line_rule = list()
    if (!is.null(rotation) && is.null(shade) && is.null(line)) {
      # htv ----
      if (which_rot == "htv") {
        for (i in 1:3) {
          rot_ruleG = c(h, d, v)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      }  # vth ----
      else if (which_rot == "vth") {
        for (i in 1:3) {
          rot_ruleG = c(v,d,h)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      } # dth ----
      else if (which_rot == "dth") {
        for (i in 1:3) {
          rot_ruleG = c(d,h,v)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      } # dtv -----
      else if (which_rot == "dtv") {
        for (i in 1:3) {
          rot_ruleG = c(d,v,h)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      }
      
      the_rule[["rotation"]] = rot_rule
      
    } else if (!is.null(shade) && is.null(rotation) && is.null(line)) {
      if (which_shade == "wtg") {
        for (i in 1:3) {
          shade_ruleG = c(sw, sb, sg)
          shade_rule[[i]] = shade_ruleG
        }
      } else if (which_shade == "wtb") {
        for (i in 1:3) {
          shade_ruleG = c(sw, sg, sb)
          shade_rule[[i]] = shade_ruleG
        }
      } else if (which_shade == "btw") {
        for (i in 1:3) {
          shade_ruleG = c(sb, sg, sw)
          shade_rule[[i]] = shade_ruleG
        }
      }  else if (which_shade == "btg") {
        for (i in 1:3) {
          shade_ruleG = c(sb, sw, sg)
          shade_rule[[i]] = shade_ruleG
        }
      }
      the_rule[["shade"]] = shade_rule
      
    } else if(!is.null(line) && is.null(shade) && is.null(rotation)) {
      if (which_line == "sdad") {
        for (i in 1:3) {
          line_ruleG = c(s, da, do) 
          line_rule[[i]] = line_ruleG
        } 
      } else if (which_line == "dads") {
        for (i in 1:3) {
          line_ruleG = c(da, do, s) 
          line_rule[[i]] = line_ruleG
        }
      } else if (which_line == "sdda") {
        for (i in 1:3) {
          line_ruleG = c(s, do, da) 
          line_rule[[i]] = line_ruleG
        }
      } else if (which_line == "ddas") {
        for (i in 1:3) {
          line_ruleG = c(do, da, s) 
          line_rule[[i]] = line_ruleG
        }
      }
      the_rule[["line"]] = line_rule
    } else if (!is.null(line) && !is.null(shade) && !is.null(rotation) ) {
      # htv ----
      if (which_rot == "htv") {
        for (i in 1:3) {
          rot_ruleG = c(h, d, v)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      }  # vth ----
      else if (which_rot == "vth") {
        for (i in 1:3) {
          rot_ruleG = c(v,d,h)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      } # dth ----
      else if (which_rot == "dth") {
        for (i in 1:3) {
          rot_ruleG = c(d,h,v)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      } # dtv -----
      else if (which_rot == "dtv") {
        for (i in 1:3) {
          rot_ruleG = c(d,v,h)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      }
      
      the_rule[["rotation"]] = rot_rule
      if (which_shade == "wtg") {
        for (i in 1:3) {
          shade_ruleG = c(sw, sb, sg)
          shade_rule[[i]] = shade_ruleG
        }
      } else if (which_shade == "wtb") {
        for (i in 1:3) {
          shade_ruleG = c(sw, sg, sb)
          shade_rule[[i]] = shade_ruleG
        }
      } else if (which_shade == "btw") {
        for (i in 1:3) {
          shade_ruleG = c(sb, sg, sw)
          shade_rule[[i]] = shade_ruleG
        }
      }  else if (which_shade == "btg") {
        for (i in 1:3) {
          shade_ruleG = c(sb, sw, sg)
          shade_rule[[i]] = shade_ruleG
        }
      }
      the_rule[["shade"]] = shade_rule
      
      if (which_line == "sdad") {
        for (i in 1:3) {
          line_ruleG = c(s, da, do) 
          line_rule[[i]] = line_ruleG
        } 
      } else if (which_line == "dads") {
        for (i in 1:3) {
          line_ruleG = c(da, do, s) 
          line_rule[[i]] = line_ruleG
        }
      } else if (which_line == "sdda") {
        for (i in 1:3) {
          line_ruleG = c(s, do, da) 
          line_rule[[i]] = line_ruleG
        }
      } else if (which_line == "ddas") {
        for (i in 1:3) {
          line_ruleG = c(do, da, s) 
          line_rule[[i]] = line_ruleG
        }
      }
      the_rule[["line"]] = line_rule
    }
    return(the_rule)
}



stimTri = function(object, rotation = NULL, 
                   color = NULL, 
                   line = NULL) {
  rot_rule = object[["rotation"]]
  shade_rule = object[["shade"]]
  line_rule = object[["line"]]
  # rotation only ----
  if (!is.null(rotation) & is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(rot = rot_rule[[i]][[j]], nv=3, lwd = 2)
      }
    }
  }  # color only  ---- 
  else if (is.null(rotation) & !is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(col = SetAlpha("black",shade_rule[[i]][[j]]),
                       nv=3, lwd = 2)
      }
    }
  } # line only ------
  else if(is.null(rotation) & is.null(color) & !is.null(line)){
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(lty = line_rule[[i]][[j]],
                       nv=3, lwd = 2)
      }
    }
  }
  # rotation and color ---- 
  else if (!is.null(rotation) & !is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(lty = line_rule[[i]][[j]],
                       nv=3, lwd = 2)
      }
    }
  } else if (is.null(rotation) & !is.null(color) & !is.null(line)) { # line and color ----- 
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(col = SetAlpha("black",shade_rule[[i]][[j]]),
                       nv=3, lwd = 2, lty = line_rule[[i]][[j]])
      }
    }
  } else if (!is.null(rotation) & is.null(color) & !is.null(line)) { # rotation and line ----
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(rot = rot_rule[[i]][[j]],
                       nv=3, lwd = 2, lty = line_rule[[i]][[j]])
      }
    }
  } # rotation color and line ---- 
  else if (!is.null(rotation) & !is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(rot = rot_rule[[i]][[j]],
                       col = SetAlpha("black",shade_rule[[i]][[j]]),
                       nv=3, lwd = 2, lty = line_rule[[i]][[j]])
      }
    }
  } 
}
# ellisse

# ellisse ---- 

stimElli = function(object, rotation = NULL, 
                   color = NULL, 
                   line = NULL) {
  rot_rule = object[["rotation"]]
  shade_rule = object[["shade"]]
  line_rule = object[["line"]]
  # rotation only
  if(!is.null(rotation) & is.null(color) & is.null(line)) {
     par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
  for (i in 1:length(rot_rule)) {
    for (j in 1:length(rot_rule[[i]])) {
      temp = NULL
      Canvas(15, 15)
      DrawEllipse(x = 0,
                  radius.x = 10, 
                  radius.y = 15, 
                  lwd = 2, 
                  rot = rot_rule[[i]][[j]], plot = T)
    }
  }
  } # color only ----- 
  else if (is.null(rotation) & !is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    col = SetAlpha("black",shade_rule[[i]][[j]]), 
                    plot = T)
      }
    }
  } # line only -----
  else if (is.null(rotation) & is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    plot = T, lty = line_rule[[i]][[j]])
      }
    }
  } # color and rotation ----- 
  else if (!is.null(rotation) & !is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    rot = rot_rule[[i]][[j]], 
                    col = SetAlpha("black",shade_rule[[i]][[j]]), 
                    plot = T)
      }
      }
  } # rotation and line ------
  else if (!is.null(rotation) & is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    rot = rot_rule[[i]][[j]], 
                    plot = T, lty = line_rule[[i]][[j]])
      }
    } 
  } # color and line ------
  else if (is.null(rotation) & !is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    plot = T, lty = line_rule[[i]][[j]], 
                    col = SetAlpha("black",shade_rule[[i]][[j]]))
      }
    }
  } # color rotation line ----- 
  else if (!is.null(rotation) & !is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    rot = rot_rule[[i]][[j]], 
                    col = SetAlpha("black",shade_rule[[i]][[j]]), 
                    plot = T, lty = line_rule[[i]][[j]])
      }
    }
  } 
  }

```


La regola generale è implementata in una funzione che, per il momento, serve a genera o delle ellissi (funzione `stimElli()` nel file `newEllisse.R`) o dei triangoli (funzione `stimTri()` nel file `triangolo.R`). 

Mi sono basata sulle regole della macrocategoria "Relation". 
Per il momento le funzioni funzionano con una serie di regole pre definite che ho dato io sulla logica delle immagini presenti su drive. Ad esempio, la rotazione può avvenire "vertical-to-horizontal" (`vth`) o "horizontal-to-vertical" (`htv`). 
L'ideale (anche pensando a una shiny app) sarebbe di lasciare inserire i valori a mano, ad esempio per la rotazione, e una regola (e.g., clockwise, andticlockwise) e generare lo stimolo. Sono solo all'inizio. 

Generazione della regola: 

```{r}
my_rule = rule_relation(rotation = T,  which_rot = "vth", 
                         shade = T, which_shade = "wtg",
                         line = T, which_line = "sdad")
```

