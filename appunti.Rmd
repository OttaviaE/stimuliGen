---
title: "appunti"
author: "Ottavia M. Epifania"
date: "`r Sys.Date()`"
output: 
    bookdown::html_document2:
        toc: true
        toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r echo=F}
source("newEllisse.R")
source("ruleGen.R")
source("triangolo.R")
```


Quello che serve/può variare: 

- numero di stimuli (quanti per riga e quanti per colonna)

- se si vuole riempire per riga o per colonna (questo lo vedo in un secondo momento) (anche se penso che usando `matrix(c2,2, byrow=F))` si dovrebbe forzare la compilazione per colonna

- la grandezza (fissa, variabile)

- la figura (per ora sono in grado di fare il rettangolo, il triangolo, il quadrato e forse il rombo)

- il riempimento

- bordi (ci sto ancora studiando)

- la posizione del punto interogativo (Rome wasn't built in a day)

# 19/09/2022
## Relation rule 

La regola generale è implementata in una funzione che, per il momento, serve a generare o delle ellissi (funzione `stimElli()` nel file `newEllisse.R`) o dei triangoli (funzione `stimTri()` nel file `triangolo.R`). 

Mi sono basata sulle regole della macrocategoria "Relation". 
Per il momento le funzioni funzionano con una serie di regole pre definite che ho dato io sulla logica delle immagini presenti su drive. Ad esempio, la rotazione può avvenire "vertical-to-horizontal" (`vth`) o "horizontal-to-vertical" (`htv`). 
L'ideale (anche pensando a una shiny app) sarebbe di lasciare inserire i valori a mano, ad esempio per la rotazione, e una regola (e.g., clockwise, andticlockwise) e generare lo stimolo. Sono solo all'inizio. 

L'idea generale è che le tutte le regole che si desidera implentare vengano salvate all'interno un oggetto. Questo oggetto viene passato poi alle funzioni per generare gli stimoli, dove non rimane altro da fare che specificare le regole che si vogliono vedere effettivamente implementate nello stimolo.

<details><summary>Vedi codice</summary>
```{r rule, eval=F}
# triangolo ---- 

library(DescTools)
# 19/09/2022 ----- 
# prova generazione di regole con liste e array e tante speranze ---- 
# RELATION: UNARY #
# The same pattern is repeated on each row (the first element determines the second
# and the third)
# which_rot

rule_relation = function(rotation = NULL, # definisce se viene specificata la rotazione
                         which_rot = c("htv", "vth", # quale rotazione
                                      "dtv", "dth"), 
                         shade = NULL, # definisce se viene specificata la colorazione
                         which_shade = c("wtg", "wtb", # quale tipo di sfumratura
                                         "btw", "btg"),
                         line = NULL, # definisce se viene specificata la linea
                         which_line = c("sdad", "dads",  # quale tipo di riga
                                        "sdda", "ddas")) {
  the_rule = list()
  # which_rots
    h = 0; d= pi/3; v = pi/2 # definisce i radianti per l'ellisse orizzonatle 
    rot_rule = list() # diagonale e verticale
    # colors 
    sw = 0; sg = 0.10; sb = 0.6 # definisce i  livelli di sfumuatura per ottenere  bianco, grigio, nero
    shade_rule = list()
    # which_line 
    s = 1; da = 5; do = 3 # definisce la riga continua, dashed, a puntini
    line_rule = list()
    if (!is.null(rotation) && is.null(shade) && is.null(line)) {
      # htv ----
      if (which_rot == "htv") {
        for (i in 1:3) {
          rot_ruleG = c(h, d, v)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      }  # vth ----
      else if (which_rot == "vth") {
        for (i in 1:3) {
          rot_ruleG = c(v,d,h)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      } # dth ----
      else if (which_rot == "dth") {
        for (i in 1:3) {
          rot_ruleG = c(d,h,v)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      } # dtv -----
      else if (which_rot == "dtv") {
        for (i in 1:3) {
          rot_ruleG = c(d,v,h)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      }
      
      the_rule[["rotation"]] = rot_rule
      
    } else if (!is.null(shade) && is.null(rotation) && is.null(line)) {
      if (which_shade == "wtg") {
        for (i in 1:3) {
          shade_ruleG = c(sw, sb, sg)
          shade_rule[[i]] = shade_ruleG
        }
      } else if (which_shade == "wtb") {
        for (i in 1:3) {
          shade_ruleG = c(sw, sg, sb)
          shade_rule[[i]] = shade_ruleG
        }
      } else if (which_shade == "btw") {
        for (i in 1:3) {
          shade_ruleG = c(sb, sg, sw)
          shade_rule[[i]] = shade_ruleG
        }
      }  else if (which_shade == "btg") {
        for (i in 1:3) {
          shade_ruleG = c(sb, sw, sg)
          shade_rule[[i]] = shade_ruleG
        }
      }
      the_rule[["shade"]] = shade_rule
      
    } else if(!is.null(line) && is.null(shade) && is.null(rotation)) {
      if (which_line == "sdad") {
        for (i in 1:3) {
          line_ruleG = c(s, da, do) 
          line_rule[[i]] = line_ruleG
        } 
      } else if (which_line == "dads") {
        for (i in 1:3) {
          line_ruleG = c(da, do, s) 
          line_rule[[i]] = line_ruleG
        }
      } else if (which_line == "sdda") {
        for (i in 1:3) {
          line_ruleG = c(s, do, da) 
          line_rule[[i]] = line_ruleG
        }
      } else if (which_line == "ddas") {
        for (i in 1:3) {
          line_ruleG = c(do, da, s) 
          line_rule[[i]] = line_ruleG
        }
      }
      the_rule[["line"]] = line_rule
    } else if (!is.null(line) && !is.null(shade) && !is.null(rotation) ) {
      # htv ----
      if (which_rot == "htv") {
        for (i in 1:3) {
          rot_ruleG = c(h, d, v)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      }  # vth ----
      else if (which_rot == "vth") {
        for (i in 1:3) {
          rot_ruleG = c(v,d,h)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      } # dth ----
      else if (which_rot == "dth") {
        for (i in 1:3) {
          rot_ruleG = c(d,h,v)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      } # dtv -----
      else if (which_rot == "dtv") {
        for (i in 1:3) {
          rot_ruleG = c(d,v,h)
          rot_rule[[i]] = rep(rot_ruleG[i], length(rot_ruleG))
        }
      }
      
      the_rule[["rotation"]] = rot_rule
      if (which_shade == "wtg") {
        for (i in 1:3) {
          shade_ruleG = c(sw, sb, sg)
          shade_rule[[i]] = shade_ruleG
        }
      } else if (which_shade == "wtb") {
        for (i in 1:3) {
          shade_ruleG = c(sw, sg, sb)
          shade_rule[[i]] = shade_ruleG
        }
      } else if (which_shade == "btw") {
        for (i in 1:3) {
          shade_ruleG = c(sb, sg, sw)
          shade_rule[[i]] = shade_ruleG
        }
      }  else if (which_shade == "btg") {
        for (i in 1:3) {
          shade_ruleG = c(sb, sw, sg)
          shade_rule[[i]] = shade_ruleG
        }
      }
      the_rule[["shade"]] = shade_rule
      
      if (which_line == "sdad") {
        for (i in 1:3) {
          line_ruleG = c(s, da, do) 
          line_rule[[i]] = line_ruleG
        } 
      } else if (which_line == "dads") {
        for (i in 1:3) {
          line_ruleG = c(da, do, s) 
          line_rule[[i]] = line_ruleG
        }
      } else if (which_line == "sdda") {
        for (i in 1:3) {
          line_ruleG = c(s, do, da) 
          line_rule[[i]] = line_ruleG
        }
      } else if (which_line == "ddas") {
        for (i in 1:3) {
          line_ruleG = c(do, da, s) 
          line_rule[[i]] = line_ruleG
        }
      }
      the_rule[["line"]] = line_rule
    }
    return(the_rule)
}

```
</details>

## Ellipse generation



<details><summary>Vedi codice</summary>
```{r ellipse, eval=FALSE}

# ellisse ---- 

stimElli = function(object, rotation = NULL, 
                   color = NULL, 
                   line = NULL) {
  rot_rule = object[["rotation"]]
  shade_rule = object[["shade"]]
  line_rule = object[["line"]]

  if (is.null(rotation) & is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    rot = rot_rule[[i]][[j]], 
                    col = SetAlpha("black",shade_rule[[i]][[j]]), 
                    plot = T, lty = line_rule[[i]][[j]])
      }
    }   # rotation only -----
  } else if (!is.null(rotation) & is.null(color) & is.null(line)) {
     par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
  for (i in 1:length(rot_rule)) {
    for (j in 1:length(rot_rule[[i]])) {
      temp = NULL
      Canvas(15, 15)
      DrawEllipse(x = 0,
                  radius.x = 10, 
                  radius.y = 15, 
                  lwd = 2, 
                  rot = rot_rule[[i]][[j]], plot = T)
    }
  }
  } # color only ----- 
  else if (is.null(rotation) & !is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    col = SetAlpha("black",shade_rule[[i]][[j]]), 
                    plot = T)
      }
    }
  } # line only -----
  else if (is.null(rotation) & is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    plot = T, lty = line_rule[[i]][[j]])
      }
    }
  } # color and rotation ----- 
  else if (!is.null(rotation) & !is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    rot = rot_rule[[i]][[j]], 
                    col = SetAlpha("black",shade_rule[[i]][[j]]), 
                    plot = T)
      }
      }
  } # rotation and line ------
  else if (!is.null(rotation) & is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    rot = rot_rule[[i]][[j]], 
                    plot = T, lty = line_rule[[i]][[j]])
      }
    } 
  } # color and line ------
  else if (is.null(rotation) & !is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    plot = T, lty = line_rule[[i]][[j]], 
                    col = SetAlpha("black",shade_rule[[i]][[j]]))
      }
    }
  } # color rotation line ----- 
  else if (!is.null(rotation) & !is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas(15, 15)
        DrawEllipse(x = 0,
                    radius.x = 10, 
                    radius.y = 15, 
                    lwd = 2, 
                    rot = rot_rule[[i]][[j]], 
                    col = SetAlpha("black",shade_rule[[i]][[j]]), 
                    plot = T, lty = line_rule[[i]][[j]])
      }
    }
  } 
  }

```
</details>

## Triangle generation

<details><summary>Vedi codice</summary>
```{r eval=F}
# triangolo ---- 

# triangolo ---- 

stimTri = function(object, rotation = NULL, 
                   color = NULL, 
                   line = NULL) {
  rot_rule = object[["rotation"]]
  shade_rule = object[["shade"]]
  line_rule = object[["line"]]
  if (is.null(rotation) & is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(rot = rot_rule[[i]][[j]],
                       col = SetAlpha("black",shade_rule[[i]][[j]]),
                       nv=3, lwd = 2, lty = line_rule[[i]][[j]])
      }
    }
  } else if (!is.null(rotation) & is.null(color) & is.null(line)) {   # rotation only ----
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(rot = rot_rule[[i]][[j]], nv=3, lwd = 2)
      }
    }
  }  # color only  ---- 
  else if (is.null(rotation) & !is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(col = SetAlpha("black",shade_rule[[i]][[j]]),
                       nv=3, lwd = 2)
      }
    }
  } # line only ------
  else if(is.null(rotation) & is.null(color) & !is.null(line)){
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(lty = line_rule[[i]][[j]],
                       nv=3, lwd = 2)
      }
    }
  }
  # rotation and color ---- 
  else if (!is.null(rotation) & !is.null(color) & is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(col = SetAlpha("black",shade_rule[[i]][[j]]), 
                       rot = rot_rule[[i]][[j]],
                       nv=3, lwd = 2)
      }
    }
  } else if (is.null(rotation) & !is.null(color) & !is.null(line)) { # line and color ----- 
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(col = SetAlpha("black",shade_rule[[i]][[j]]),
                       nv=3, lwd = 2, lty = line_rule[[i]][[j]])
      }
    }
  } else if (!is.null(rotation) & is.null(color) & !is.null(line)) { # rotation and line ----
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(rot = rot_rule[[i]][[j]],
                       nv=3, lwd = 2, lty = line_rule[[i]][[j]])
      }
    }
  } # rotation color and line ---- 
  else if (!is.null(rotation) & !is.null(color) & !is.null(line)) {
    par(mfrow=c(3,3), mar = c(0.5,6,0.5,2)+0.1)
    for (i in 1:length(rot_rule)) {
      for (j in 1:length(rot_rule[[i]])) {
        temp = NULL
        Canvas()
        DrawRegPolygon(rot = rot_rule[[i]][[j]],
                       col = SetAlpha("black",shade_rule[[i]][[j]]),
                       nv=3, lwd = 2, lty = line_rule[[i]][[j]])
      }
    }
  } 
}


```
</details>


### Esempio

Generazione delle regole: 

```{r}
my_rule = rule_relation(rotation = T,  which_rot = "vth", 
                         shade = T, which_shade = "wtg",
                         line = T, which_line = "sdad")
```

Si può scegliere anche di non mettere tutte le regole insieme, ma di selezionarne solo alcune.


L'oggetto `my_rule` è una lista di liste: 

```{r echo=FALSE}
str(my_rule)
```

Contiene tre liste (``r names(my_rule)``), ognuna di lunghezza 3. Ogni lista contiene le regole relative al suo nome per ora quindi abbiamo solo rotazione, solore e linea di contorno. 

Una volta salvate le regole, si possono usare per generare gli stimoli: 

```{r}
stimElli(my_rule)
```

Se non viene specificato nulla, vengono applicate tutte le regole in `my_rule`(rotazione, colore, linea), altrimenti^[per come ho scritto ora la funzione, se non vengono passati argomenti funziona solo se in `my_rule` sono presenti tutte le regole, ma si può cambiare con poco]: 

```{r}
stimElli(my_rule, rotation =T)
```

Stessa cosa per il triangolo: 

```{r}
stimTri(my_rule, line =T)
```

Oppure combinando diversi elementi e ottenendo delle relazioni binarie: 

```{r}
stimElli(my_rule, color = T, rotation = T)
```

```{r}
stimTri(my_rule, line = T, rotation = T)
```

